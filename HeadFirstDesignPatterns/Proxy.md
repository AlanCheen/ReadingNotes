# 代理模式

> 这一章节的内容较多，笔记比较乱，还是看书好些。

代理模式： **为另一个对象提供一个替身或占位符以控制对这个对象的访问。**  

所谓代理（proxy），就是代表某个真实的对象。  

代理要做的就是：**控制和管理访问(控制对象访问)**  

why? 是因为Client不知道如何和远程对象沟通。从某方面来看，远程代理控制访问，可以帮忙处理一些细节（比如网络，IPC）。

![类图](http://ww1.sinaimg.cn/large/98900c07jw1f62sqklu5rj20m80cegm9.jpg)
（Subject可以是接口）  


代理最主要的方法：

**远程代理**（remote proxy），好比『远程对象的本地代表』;远程代理是 **一种对象，活在不同的Java虚拟机(JVM)堆中**（更一般的说法为，在不同 **地址空间运行的远程对象**）  

PS：在Android中的代理，如 Binder，处理不同进程间IPC，就是在不同的地址。  

变体代理方法：  

1. 远程代理 控制访问远程对象。
2. 虚拟代理控制访问创建开销大的资源（在必要的时候才创建对象，对象创建完了才委托给对象）
3. 保护代理基于权限控制对资源的访问。  

本地代表，是一种可以由本地方法调用的对象，其行为会转发到远程对象中。  

工作原理示意图：  

![](http://ww3.sinaimg.cn/large/98900c07jw1f62uet9p85j20gt07l3zc.jpg)

书中提到了 `RMI` 技术，它将 客户辅助对象称为`stub`（桩）,服务器辅助对象称为`skeleton`（g骨架）。

BONUS：    

- 原语类型（primitive-原来常说的基本类型），传输过程允许的对象类型要注意，自己定义的类的对象需要实现Serializable（Java）  
- 当不需要传输的时候，用`transient`来修饰变量。   

例子让我想起来Android中的 `AIDL`和`Binder`，忽然间懂了好多。  

## 保护代理

可以在运行时动态地创建一个代理类，实现一个或多个接口，并将方法的调用转发到你所指定的类。因为实际的代理类是在运行时创建的，我们称这个Java技术为：**动态代理**。大名鼎鼎的  `retrofit` 用的就是动态代理。


动态代理的UML：


![](http://ww3.sinaimg.cn/large/98900c07jw1f65z5ys3pwj20gz09adgm.jpg)  

## 要点

1. 代理模式为另一个对象提供代表，以便控制客户对对象的访问，管理访问的方式有许多种。
2. 远程代理管理客户和远程对象之间的交互。
3. 虚拟代理控制访问实例化对对象方法的访问。
4. 代理模式有许多变体，例如：缓存代理、同步代理、防火墙代理和写入时复制代理。
5. 代理在结构上类似装饰者，但是目的不同。
6. 装饰者模式为对象加上行为，而代理则是控制访问。
7. Java内置的代理支持，可以根据需要建立动态代理，并将所有调用分配到所选的处理器。
8. 就和其他的包装者（wrapper)一样，代理会造成你的设计中类的数目增加。
