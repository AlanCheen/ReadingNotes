# 第1章-并发编程的挑战

#### 上下文切换

单核处理器也支持多线程执行代码，CPU 通过给每个线程分配 CPU 时间片来实现这个机制。通过不停切换线程执行，让我们『感觉是多个线程同时执行的』。

    时间片是 『 CPU 分配给各个线程的时间』，一般几十毫秒。

CPU 通过时间片分配算法来循环执行任务，当前任务执行一个时间片会切换到下一个任务。但是
，在**切换前保存上一个任务**，以便下次切换回这个任务时，可以**再加载**这个任务的状态。

所以**『任务从保存到再加载的过程就是一次上下文切换』**。

由于线程有**创建**和**上下文切换**的开销，所以多线程不一定更快。

#### 减少上下文切换

减少的方法有

1. 无锁并发编程。
2. CAS 算法。Java 的 Atomic 包使用 CAS 算法来更新数据，而不需要加锁。
3. 使用最少线程。避免创建不需要的线程
4. 使用协程。协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。（GO 语言有）



#### 死锁

两个线程相互等待对方释放锁就会导致死锁。

避免死锁的常见方法：
1. 避免一个线程同时获取多个锁。
2. 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。
3. 尝试使用定时锁，使用 lock.tryLock(timeout)来替代使用内部锁机制。
4. 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。


#### 资源极限的挑战



