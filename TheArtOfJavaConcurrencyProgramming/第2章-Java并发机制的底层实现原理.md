# 第2章-Java并发机制的底层实现原理

Java 代码在编译后会变成 Java 字节码，字节码被类加载器加载到 JVM 里，JVM 执行字节码，最终需要装化为汇编指令在 CPU 上执行，Java 中所使用的并发机制依赖于 JVM 的实现和 CPU 指令。


## volatile

volatile是**轻量级**的 synchronized ；恰当使用下，它比synchronized成本更低，因为**它不会引起线程上下文切换和调度**。

volatile 在多处理器开发中 **保证了共享变量的『可见性』，这能保证共享变量能被准确和一致的更新。** 

可见性的意思是： **当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。**

#### volatile的原理

volatile 修饰的变量，在进行写操作的时候，会多一条用`lock`修饰的汇编代码。

lock 前缀的指令 的作用：

1. 将当前处理器缓存行的数据写回到系统内存。
2. 这个写回内存的操作会使其他 CPU 缓存了该内存地址的数据无效。

理解： 把自己的缓存写会系统内存，并使其他内存地址的数据无效，这就迫使其他CPU操作该变量的时候，会**重新从系统内存中获取**


## synchronized

synchronized 基础：Java 中的每一个对象都可以作为锁。
 
- 对于普通同步方法，锁是当前实例对象。
- 对于静态同步方法，锁是当前类的 Class 对象。
- 对于同步方法块，锁是 Synchronized 括号里配置的对象。

代码块同步是通过 monitorenter 和 monitorexit 指令来实现。
方法，没说。

补充：synchronized 修饰方法，其常量池中多了**ACC_SYNCHRONIZED标示符**。JVM就是根据该标示符来实现方法的同步的：**当方法调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor**。


锁的信息放在 Java 对象头里。


 减少 获得锁 和 释放锁带来的性能--》 偏向锁 和 轻量级锁


## 原子操作原理

原子操作 atomic operation ：**不可中断的一个或一系列的操作**。

CAS：比较并交换，Compare and Swap，CAS 操作需要两个数组，一个旧值和一个新值，在操作期间，先比较旧值有没有发生变化，如果没有发生变化，才交换成新值，发生了变化则不交换。


处理器如何处理原子操作？:

1. 使用总线锁保证原子性（直接锁总线，消耗大）
2. 使用缓存锁保证原子性


#### Java 如何实现原子操作

锁 和 循环CAS 的方式来实现原子操作。




亦非猿注：
voliate 不具备原子特性
voliate 不会像锁那样造成阻塞

使用voliate，必须同时满足下面两个条件：

1. 对变量的写操作不依赖与当前值。（比如i++就不行）
2. 该变量没有包含在具有其他变量的不变式中。

 volatile 的限制 —— 只有在状态真正独立于程序内其他内容时才能使用 volatile


