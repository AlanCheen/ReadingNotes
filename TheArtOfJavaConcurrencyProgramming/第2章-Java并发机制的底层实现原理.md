# 第2章-Java并发机制的底层实现原理.md

Java 代码在编译后会变成 Java 字节码，字节码被类加载器加载到 JVM 里，JVM 执行字节码，最终需要装化为汇编指令在 CPU 上执行，Java 中所使用的并发机制依赖于 JVM 的实现和 CPU 指令。


## volatile

volatile是轻量级的 synchronized ；比synchronized成本更低，它不会引起线程上下文切换和调度。

volatile 保证了贡献变量的『可见性』，这能保证共享变量能被准确和一致的更新。 

可见性的意思是： **当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。**

原理：

volatile 修饰的变量，在进行写操作的时候，会多一条用`lock`修饰的汇编代码。

lock 的作用：

1. 将当前处理器缓存行的数据写回到系统内存。
2. 这个写回内存的操作会使其他 CPU 缓存了该内存地址的数据无效。

理解： 把自己的缓存写会系统内存，并使其他内存地址的数据无效，这就迫使其他CPU操作该变量的时候，会**重新从系统内存中获取**


## synchronized

synchronized 基础：Java 中的每一个对象都可以作为锁。
 
- 对于普通同步方法，锁是当前实例对象。
- 对于静态同步方法，锁是当前类的 Class 对象。
- 对于同步方法块，锁是 Synchronized 括号里配置的对象。

代码块同步是通过 monitorenter 和 monitorexit 指令来实现。
方法，没说。


锁的信息放在 Java 对象头里。


 减少 获得锁 和 释放锁带来的性能--》 偏向锁 和 轻量级锁


## 原子操作原理

原子操作 atomic operation ：不可中断的一个或一系列的操作。

CAS：比较并交换，Compare and Swap，CAS 操作需要两个数组，一个旧值和一个新值，在操作期间，先比较旧值有没有发生变化，如果没有发生变化，才交换成新值，发生了变化则不交换。


处理器如何处理原子操作？:

1. 使用总线锁保证原子性（直接锁总线，消耗大）
2. 使用缓存锁保证原子性


#### Java 如何实现原子操作

锁 和 循环CAS 的方式来实现原子操作。








